\documentclass[letterpaper,11pt,twoside]{article}

\usepackage[left=1in, right=1in, bottom=1.25in, top=1.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{setspace}
%\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\allowdisplaybreaks
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage[mathscr]{euscript}
\usepackage{latexsym,bbm,xspace,graphicx,float,mathtools,mathdots,xspace}
\usepackage{enumitem}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{bm}
\usepackage[backref, colorlinks,citecolor=blue,linkcolor=magenta,bookmarks=true]{hyperref}
\usepackage[nameinlink]{cleveref}

% tikz
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{tikz}

\usepackage{tablefootnote}

\fancypagestyle{plain}{%
\fancyhf{} % clear all header and footer fields
\fancyfoot[C]{\textbf{\thepage}} % except the center
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{assumption}{Assumption}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Conjecture}
\newtheorem{proposition}{Proposition}
\newtheorem{observation}{Observation}
\newtheorem{claim}{Claim}
\newtheorem{property}{Property}
\newtheorem{op}{Open Problem}
\newtheorem{problem}{Problem}
\newtheorem{question}{Question}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{sketch}{Sketch}
\newtheorem{idea}{Idea}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newtheoremstyle{restate}{}{}{\itshape}{}{\bfseries}{~(restated).}{.5em}{\thmnote{#3}}
\theoremstyle{restate}
\newtheorem*{restate}{}



\crefname{theorem}{Theorem}{Theorems}
\crefname{assumption}{Assumption}{Assumptions}
\crefname{corollary}{Corollary}{Corollaries}
\crefname{lemma}{Lemma}{Lemmas}
\crefname{conjecture}{Conjecture}{Conjectures}
\crefname{proposition}{Proposition}{Propositions}
\crefname{observation}{Observation}{Observations}
\crefname{claim}{Claim}{Claims}
\crefname{property}{Property}{Properties}
\crefname{op}{Open Problem}{Open Problems}
\crefname{problem}{Problem}{Problems}
\crefname{question}{Question}{Questions}

% \crefname{fact}{Fact}{Facts}

\crefname{definition}{Definition}{Definitions}
\crefname{example}{Example}{Examples}
\crefname{sketch}{Sketch}{Sketches}
\crefname{idea}{Idea}{Ideas}

% \crefname{condition}{Condition}{Conditions}

\crefname{remark}{Remark}{Remarks}



\crefname{equation}{Equation}{Equations}
\crefname{figure}{Figure}{Figures}
\crefname{table}{Table}{Tables}



%%%%%%%%%%%%%%%%%%%%%%%%%%
% GENERAL-PURPOSE MACROS %
%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ignore}[1]{}
\newcommand{\eps}{\epsilon}
\newcommand{\simple}{\mathrm{simple}}
\newcommand{\E}{\operatorname{{\bf E}}}
\newcommand{\Ex}{\mathop{{\bf E}\/}}
\renewcommand{\Pr}{\operatorname{{\bf Pr}}}
\newcommand{\Prx}{\mathop{{\bf Pr}\/}}
\newcommand{\Var}{\operatorname{{\bf Var}}}
\newcommand{\Varx}{\mathop{{\bf Var}\/}}
\newcommand{\tO}{\tilde{O}}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\rZ}{\mathcal{Z}}

\DeclareMathOperator\erf{erf}

\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\bcalZ}{\bm{\mathcal{Z}}}
\newcommand{\bx}{\bm{x}}
\newcommand{\by}{\bm{y}}
\newcommand{\bxi}{\bm{\xi}}

% Blind (markerless) footnotes
\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}

%%%%%%%%%%%%%%%%%%
% NUMBER SYSTEMS %
%%%%%%%%%%%%%%%%%%
\newcommand{\R}{\mathbb R}
\newcommand{\RR}{\R_{\geq 0}}
\newcommand{\C}{\mathbb C}
\newcommand{\N}{\mathbb N}
\newcommand{\NN}{\N_{\geq 1}}
\newcommand{\Z}{\mathbb Z}

\renewcommand{\i}{\mathbf{i}}   % for complex numbers
\renewcommand{\d}{\mathrm{d}}   % for integrals
\newcommand{\lhs}{\mathrm{LHS}} % for inequalities
\newcommand{\rhs}{\mathrm{RHS}} % for inequalities
\newcommand{\supp}{\mathrm{supp}}
\renewcommand{\hat}[1]{\widehat{#1}}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\sig}{\mathrm{sig}}

\newcommand{\comment}[1]{}

% Define colors
\def\colorful{1}
\ifnum\colorful=1
\newcommand{\violet}[1]{{\color{violet}{#1}}}
\newcommand{\orange}[1]{{\color{orange}{#1}}}
\newcommand{\blue}[1]{{{\color{blue}#1}}}
\newcommand{\red}[1]{{\color{red} {#1}}}
\newcommand{\green}[1]{{\color{green} {#1}}}
\newcommand{\pink}[1]{{\color{pink}{#1}}}
\newcommand{\gray}[1]{{\color{gray}{#1}}}
\fi
\ifnum\colorful=0
\newcommand{\violet}[1]{{{#1}}}
\newcommand{\orange}[1]{{{#1}}}
\newcommand{\blue}[1]{{{#1}}}
\newcommand{\red}[1]{{{#1}}}
\newcommand{\green}[1]{{{#1}}}
\newcommand{\gray}[1]{{{#1}}}
\fi

\title{Homework 4}
% \author{Tim Randolph}
\date{COMS W3261, Summer A 2022}

\begin{document}

\maketitle

This homework is due \textbf{Tuesday, 6/21/2022, at 11:59pm EST}. Submit to GradeScope (course code: 2KGDW8).

\textbf{Grading policy reminder:} \LaTeX~is preferred, but neatly typed or handwritten solutions are acceptable. I recommend using the .tex file for the homework as a template to write up your answers. Your TAs may dock points for indecipherable writing.\\

Proofs should be complete; that is, include enough information that a reader can clearly tell that the argument is rigorous. \\

If a question is ambiguous, please state your assumptions. This way, we can give you credit for correct work. (Even better, post on Ed so that we can resolve the ambiguity.) \\

\textbf{\LaTeX~resources.}
\begin{itemize}
    \item The website \href{https://www.overleaf.com/}{Overleaf} (essentially Google Docs for LaTeX) may make compiling and organizing your .tex files easier. Here's a quick \href{https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes}{tutorial}.
    \item \href{https://detexify.kirelabs.org/classify.html}{Detexify} is a nice tool that lets you draw a symbol and returns the \LaTeX~codes for similar symbols. 
    \item The tool \href{https://www.tablesgenerator.com/}{Table Generator} makes building tables in \LaTeX~much easier.
    \item The tool \href{http://madebyevan.com/fsm/}{Finite State Machine Designer} may be useful for drawing automata. See also this example (\href{https://static.us.edusercontent.com/files/HZeTXimODzWeLvHIqsvjL2BG}{PDF}) (\href{https://static.us.edusercontent.com/files/RI3W8tQNvHMWFe9MkXV1KztA}{.tex}) of how to make fancy edges (courtesy of Eumin Hong).
    \item The website \href{https://www.mathcha.io/}{mathcha.io} allows you to draw diagrams and convert them to \LaTeX~code.
    \item To use the previous drawing tools (and for most drawing in \LaTeX), you'll need to use the package Tikz (add the command ``\textbackslash usepackage\{tikz\}'' to the preamble of your .tex file to import the package). 
    \item \href{https://www.overleaf.com/learn/latex/Positioning_of_Figures}{This tutorial} is a helpful guide to positioning figures.
\end{itemize}  



\clearpage
\section{Problem 1 (7 points)}
    The following questions concern the pushdown automaton $P$ pictured below.
    \begin{center}
    \begin{tikzpicture}[scale=0.2]
    \tikzstyle{every node}+=[inner sep=0pt]
    \draw [black] (16.8,-24.9) circle (3);
    \draw [black] (30.6,-17) circle (3);
    \draw [black] (30.6,-17) circle (2.4);
    \draw [black] (30.6,-31.7) circle (3);
    \draw [black] (47.4,-31.7) circle (3);
    \draw [black] (47.4,-17) circle (3);
    \draw [black] (47.4,-17) circle (2.4);
    \draw [black] (10.2,-24.9) -- (13.8,-24.9);
    \fill [black] (13.8,-24.9) -- (13,-24.4) -- (13,-25.4);
    \draw [black] (19.033,-22.898) arc (129.10243:110.47672:31.01);
    \fill [black] (27.74,-17.91) -- (26.82,-17.72) -- (27.17,-18.66);
    \draw (19.46,-19.55) node [above] {$0,\mbox{ }\epsilon\rightarrow\epsilon$};
    \draw [black] (29.277,-14.32) arc (234:-54:2.25);
    \draw (30.6,-9.75) node [above] {$0,\mbox{ }\epsilon\rightarrow\epsilon$};
    \fill [black] (31.92,-14.32) -- (32.8,-13.97) -- (31.99,-13.38);
    \draw [black] (27.726,-30.841) arc (-108.94041:-123.52347:37.307);
    \fill [black] (27.73,-30.84) -- (27.13,-30.11) -- (26.81,-31.05);
    \draw (19.65,-29.54) node [below] {$\epsilon,\epsilon\rightarrow\$$};
    \draw [black] (31.923,-34.38) arc (54:-234:2.25);
    \draw (30.6,-38.95) node [below] {$0,\mbox{}\epsilon \rightarrow 0$};
    \fill [black] (29.28,-34.38) -- (28.4,-34.73) -- (29.21,-35.32);
    \draw [black] (33.6,-31.7) -- (44.4,-31.7);
    \fill [black] (44.4,-31.7) -- (43.6,-31.2) -- (43.6,-32.2);
    \draw (39,-32.2) node [below] {$\#,\mbox{ }\epsilon \rightarrow \epsilon$};
    \draw [black] (48.723,-34.38) arc (54:-234:2.25);
    \draw (47.4,-38.95) node [below] {$0,\mbox{ }0 \rightarrow \epsilon$};
    \fill [black] (46.08,-34.38) -- (45.2,-34.73) -- (46.01,-35.32);
    \draw [black] (47.4,-28.7) -- (47.4,-20);
    \fill [black] (47.4,-20) -- (46.9,-20.8) -- (47.9,-20.8);
    \draw (47.9,-24.35) node [right] {$\epsilon,\mbox{ }\$\rightarrow\epsilon$};
    \end{tikzpicture}
    \end{center}

    \begin{enumerate}
        \item (3 points.) Which of the following six strings are accepted by this PDA? $00\#00$, $11\#11$, $0000$, $\#000$, $0$, $000\#00$.
        
        \item (4 points.) Consider the following grammar $G$:
        \begin{align*}
            S &\rightarrow A \; | \; 0B0 \\
            A &\rightarrow 0A \; | \; \epsilon \\
            B &\rightarrow 0B0 \; | \; \#
        \end{align*}
        The language of $G$ is almost the same as the language recognized by $P$, but not quite.
        \begin{enumerate}
            \item Name a string in $L(P)$ but not in $L(G)$, and explain why it can't be derived from $S$ in $G$.
            
            \item Name a string in $L(G)$ but not in $L(P)$, and explain why it is rejected by $P$.
        \end{enumerate}
    \end{enumerate}

    \blfootnote{ Rationale: The goal of this problem is to practice evaluating pushdown automata (and context-free grammars). }
    \blfootnote{ References: Sipser p.112 for an introduction to PDAs, p.113 for the formal definition and pp.114-116 for examples. See also Lightning Review 6 on Pushdown Automata. }



\clearpage
\section{Problem 2 (8 points)}

Use the context-free pumping lemma to prove that the following language is not context-free. [Hint: the CFPL has the form ``In any context-free language, all sufficiently long strings can be divided into substrings in a way that satisfies three properties''. To show that a language is not context-free, we need to contradict this statement; i.e., show that ``In this particular language, there exists at least one long string such that \emph{no} division of this string into substrings satisfies all three properties.'']
\begin{enumerate}
    \item (8 points).
    \[
        L_1 = \{0^a\#1^a\#2^{2a} \; | \; a \geq 0\}.
    \]
    
    \blfootnote{ Rationale: The goal of this question is to practice using the context-free pumping lemma. }
    \blfootnote{ References: The CFPL is stated in Sipser p.125, with examples on pp. 128-129. See also the example video on the CFPL, which contains an example. }
\end{enumerate}

\clearpage
\section{Problem 3 (8 points)}
    An implementation-level description is less detailed than the \emph{formal description} of a TM as a 7-tuple. You do not need to specify specific states or the transition function for this question. An implementation-level description describes in prose how the TM moves its head around and manages memory.

    Example implementation-level description: A TM that recognizes the language 
    \[
        \{0^a\#0^b\#0^{c} \; | \; 2a + b = c \text{ and } a, b, c \geq 1\}.
    \]
    $M$ = ``On input string $w$:
    \begin{itemize}
        \item Scan the input from left to right to determine whether it matches the regular expression $0^+\#0^+\#0^+$. We can do this in a single pass without writing to the tape because $0^+\#0^+\#0^+$ is a regular expression and can be recognized by a DFA (i.e., a TM without the power to manipulate the tape.)
        \item Return the head to the left end of the tape.
        \item Shuttle back and forth between the $0^a$ and $0^c$ substring. Each time, we cross off one $0$ in $0^a$ and exactly two $0$'s from $0^c$. Reject if we run out of $0$'s in $0^c$.
        \item Shuttle back and forth between $0^b$ and $0^c$, crossing off one of each until all $0$'s in $0^b$ are gone. Reject if we run out of $0$'s in $0^c$.
        \item Accept if $0^c$ is entirely crossed off; reject if there are uncrossed $0$'s remaining.''
    \end{itemize}

    \begin{enumerate}
        \item (8 points). Consider the function $f$ defined on integers as follows: If $n$ is even, $f(n) = n/2$. If $n$ is odd, $f(n) = 3n+1$. It is conjectured that repeatedly applying $f$ to any integer eventually results in the number 1. For example, $f(6) = 3$, $f(3) = 10$, $f(10) = 10/2 = 5$, $f(5) = 16$, $f(16) = 8$, $f(8) = 4$, $f(4) = 2$, $f(2) = 1$.
        
        Write an implementation-level description of a TM that recognizes the language
        \[
            F = \{0^n \; | \; \text{ repeatedly applying $f$ to $n$ eventually yields $1$.}\}.
        \]
    \end{enumerate}
    


    
    \blfootnote{ Rationale: The goal of this question is to practice thinking about TM memory management; that is, writing to and reading from the tape as necessary. }
    \blfootnote{ References: Sipser pp. 174-175 contains two additional implementation-level descriptions of TMs. See also our review video on Turing Machines, which has an implementation-level description on a TM that checks multiplication. For fun, see the wiki page on the \href{https://en.wikipedia.org/wiki/Collatz_conjecture}{Collatz Conjecture} (nothing on this page is required to solve this question). }
    
\clearpage
\section{Problem 4 (12 points)}
Provide \emph{high-level descriptions} of Turing Machines that recognize the following languages. 

A high-level description is an algorithm for a Turing Machine described in prose, ignoring implementation details such as the way information is encoded or where the head needs to move. However, your TM's behavior should still be \emph{precisely specified}: it should be clear what the Turing Machine does in every case.

Example high-level description: We'll build a Turing Machine $M$ that recognizes the language 
\[
    \{\langle G\rangle \; | \; \langle G \rangle \text{ encodes a\emph{ connected graph}.}\}
\].
Our Turing Machine will implement a breadth-first search on the encoded input as follows:
\begin{itemize}
    \item First, check to see if the input encodes a graph and reject if not.
    \item Mark the first vertex $v$ in the graph.
    \item Review the encoded graph and mark every vertex adjacent to a marked vertex. Repeat this step until no new nodes are marked.
    \item Accept if all vertices are marked and reject otherwise.
\end{itemize}

\begin{enumerate}
    \item (2 points) $A_1 = \{c \; | \; a^2 + b^2 = c^2 \text{ for some pair of integers } a, b \geq 1\}$.
    
    \item (5 points) $A_2 = \{ \langle D \rangle \; | \; \langle D \rangle \text{ encodes a DFA that accepts at least one string matching } (01)^*\}$.
    
    \item (5 points) $A_3$, the language containing every encoded graph $\langle G \rangle$ that contains a \emph{Hamiltonian path}, i.e., a path containing each vertex exactly once.
    
    \blfootnote{ Rationale: The goal of this question is to practice thinking about Turing Machines as general-purpose computers that can execute algorithms for solving complex decision problems. }
    \blfootnote{ References: Sipser pp. 186-187 contains the high-level description given as an example, as well as a breakdown from the high level to the implementation level. TM descriptions later in the book (for instance, those on pp. 195-196) are also given at the high-level. }
\end{enumerate}



\clearpage
\section{Problem 5 (2 Extra Credit Points): Turing Completeness}
I know, Turing Machines are wonderful. But there are other wonderful things. For this week's extra credit problem, we will learn about things that are just as wonderful as TMs— things that are \textbf{Turing Complete} (\href{https://en.wikipedia.org/wiki/Turing_completeness}{Wikipedia}).
\subsection{Lambda Calculus (1 pt)} Since it's called the Church-Turing Thesis instead of just ``Turing Thesis'', maybe do Alonzo Church a favor and read \href{https://personal.utdallas.edu/~gupta/courses/apl/lambda.pdf}{this short tutorial} on Lambda Calculus. It is known that Lambda Calculus and Turing Machines are equivalent, i.e. Lambda Calculus is Turing Complete. In your own words, describe how you find the two equivalent models different in ``flavor.'' One short paragraph suffices. (Hint: think about their names, Lambda \textit{Calculus} vs. Turing \textit{Machines}.)\\

\subsection{Accidentally Turing Complete (1 pt)}
As intelligent and ambitious CS students, it is probably your worst nightmare to be stuck at a PowerPoint-making job. As it turns out, however, PowerPoints are \textit{wonderful} too. Read \href{https://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf}{this paper} which convinces you the above statement, then Google around and tell us one more example of unlikely Turing Completeness.\\

\blue{
    
}   



\end{document}
